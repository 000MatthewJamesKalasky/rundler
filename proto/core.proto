syntax = "proto3";
package core;

import "common.proto";

service Core {
  rpc SendOp (SendOpRequest) returns (SendOpResponse);
  rpc EstimateOpGas (EstimateGasRequest) returns (EstimateGasResponse);
  rpc GetOpByHash (GetOpByHashRequest) returns (GetOpByHashResponse);
  rpc GetOpReceipt (GetOpReceiptRequest) returns (GetOpReceiptResponse);
  rpc GetEntryPoints (GetEntryPointsRequest) returns (GetEntryPointsResponse);
}

message SendOpRequest {
  common.UserOperation op = 1;
  bytes entry_point = 2;
}

message SendOpResponse {
  oneof result {
    SubmitOpSuccess ok = 1;
    OpError err = 2;
  }
}

message EstimateGasRequest {
  common.UserOperation op = 1;
  bytes entry_point = 2;
}

message EstimateGasResponse {
  oneof result {
    EstimateGasSuccess ok = 1;
    OpError err = 2;
  }
}

message SubmitOpSuccess {
  bytes user_op_hash = 1;
}

message EstimateGasSuccess {
  bytes pre_verification_gas = 1;
  bytes verification_gas_limit = 2;
  bytes call_gas_limit = 3;
}

message OpError {
  message InvalidOp {}

  message FailedWalletSimulation {
    string entry_point_error = 1;
  }

  message FailedPaymasterSimulation {
    string paymaster_revert_message = 1;
    bytes paymaster = 2;
  }

  message UsedBannedOpcode {}

  message OutOfTimeRange {
    uint64 valid_after = 1;
    uint64 valid_until = 2;
    bytes paymaster = 3;
  }

  message ThrottledOrBanned {
    bytes paymaster = 1;
    bytes aggregator = 2;
  }

  message InvalidStake {
    bytes paymaster = 1;
    bytes aggregator = 2;
    bytes minimum_stake = 3;
    uint32 minimum_unstake_delay = 4;
  }

  message UnsupportedAggregator {
    bytes aggregator = 1;
  }

  oneof op_error_case {
    // TODO: What to do for invalid entry point? The spec doesn't say.
    InvalidOp invalid_op = 1;
    FailedWalletSimulation failed_wallet_simulation = 2;
    FailedPaymasterSimulation failed_paymaster_simulation = 3;
    UsedBannedOpcode used_banned_opcode = 4;
    OutOfTimeRange out_of_time_range = 5;
    ThrottledOrBanned throttled_or_banned = 6;
    InvalidStake invalid_stake = 7;
    UnsupportedAggregator unsupported_aggregator = 8;
  }
}

message GetOpByHashRequest {
  bytes hash = 1;
}

message GetOpByHashResponse {
  common.UserOperation op = 1;
  bytes entry_point = 2;
  uint64 block_number = 3;
  bytes block_hash = 4;
  bytes transaction_hash = 5;
}

message GetOpReceiptRequest {
  bytes hash = 1;
}

message GetOpReceiptResponse {
  bytes user_op_hash = 1;
  bytes entry_point = 2;
  bytes sender = 3;
  bytes nonce = 4;
  bytes paymaster = 5;
  bytes actual_gas_cost = 6;
  bytes actual_gas_used = 7;
  bool success = 8;
  string reason = 9;
  // TODO: figure out what goes here.
  repeated bytes logs = 10;
  // TODO: and here.
  bytes receipt = 11;
}

message GetEntryPointsRequest {}

message GetEntryPointsResponse {
  repeated bytes entry_points = 1;
}